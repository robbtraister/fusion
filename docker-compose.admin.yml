version: '3.4'

x-environment: &_environment
  DB_NAME: ${DB_NAME:-fusion_dev}
  MONGO_URL: mongodb://data:27017/${DB_NAME:-fusion_dev}
  PB_MONGODB_URI: mongodb://data:27017/${DB_NAME:-fusion_dev}

  HTTP_ENGINE: http://engine:8080
  HTTP_RESOLVER: http://resolver:8080
  LAMBDA_ENGINE:
  LAMBDA_RESOLVER:

  NODE_ENV:
  ENVIRONMENT: localhost
  CONTEXT_PATH:
  ON_DEMAND:
  DEBUG: fusion:*

networks:
  fusion:
    driver: bridge
    external: false
    internal: false

services:
  data:
    image: quay.io/washpost/mongo-localhost
    build: ./data
    environment:
      <<: *_environment
      WATCH: 'true'
    networks:
      fusion:
        aliases:
          - db
          - database
    ports:
      - '27017:27017'
    volumes:
      - './data/db:/data/db:rw'
      - './data/restore:/data/restore:rw'

  engine:
    image: quay.io/washpost/fusion-engine
    build:
      context: .
      dockerfile: serverless.Dockerfile
      args:
        LAMBDA: engine
    command: 'start:dev'
    depends_on:
      - data
    env_file:
      - .env
    environment:
      <<: *_environment
      CONTENT_BASE:
      MINIFY:
      # because we import ALL variables from .env, ignore PORT
      PORT: 8080
    networks:
      - fusion
    ports:
      - '9010:8080'
    volumes:
      # - '~/.aws:/root/.aws:ro'
      - '${FUSION_REPO:-./bundle}:/workdir/engine/bundle:rw'
      - './engine/src:/workdir/engine/src:ro'
      - './dist:/workdir/engine/dist:rw'

  resolver:
    image: quay.io/washpost/fusion-resolver
    build:
      context: .
      dockerfile: serverless.Dockerfile
      args:
        LAMBDA: resolver
    depends_on:
      - data
      - engine
    environment:
      <<: *_environment
      RESOLVE_FROM_DB: 'true' # should only be 'true' for local dev environments
      TRAILING_SLASH_RULE: # Options are FORCE, DROP, or NOOP
    networks:
      - fusion
    ports:
      - '9020:8080'
    volumes:
      - './resolver/config:/workdir/resolver/config:ro'
      - './resolver/src:/workdir/resolver/src:ro'

  memcache:
    # memcached service runs from an image, so there is no Dockerfile
    image: memcached
    command: memcached -I 10m
    networks:
      - fusion
    ports:
      - 11211:11211

  admin:
    image: quay.io/washpost/pagebuilder-nilev1:${PB_VERSION:-fusion-admin.2}
    depends_on:
      - memcache
      - data
    environment:
      <<: *_environment
      NGINX_PORT: ""
      TOMCAT_PORT: "8888"
      PB_AUTH_DISABLED: "true"
      PB_ASSETS_IMPORT_PATH: "/assets"
      PB_ASSETS_IMPORT_METHOD: "symlink"
      PB_MEMCACHED_HOST: "memcache:11211"
      PB_MONGODB_GARBAGE_COLLECTION: "false"
      PB_RENDERING_DEBUG: "true"
      PB_SYSTEM_LOG_CONFIG: "logback-info.xml"
    networks:
      - fusion
    volumes:
      # Docker will mount the folder defined in $PROJECT_REPO environment
      # variable inside the container as /assets so PageBuilder is agnostic
      # to the actual location of the assets and resources
      - "${CLASSIC_REPO}:/assets"
    ports:
      - 8888:8888

  origin:
    image: quay.io/washpost/fusion-origin
    build: ./origin
    depends_on:
      - engine
      - resolver
      - admin
    environment:
      <<: *_environment
      PB_ADMIN: http://admin:8888
    networks:
      - fusion
    ports:
      - '80:8080'
      - '8081:8081'
    volumes:
      # - '~/.aws:/home/nginx/.aws:ro'
      - './origin/src:/etc/nginx/src:ro'
      - './dist:/etc/nginx/dist:ro'
      - '${FUSION_REPO:-./bundle}/resources:/etc/nginx/resources:ro'
